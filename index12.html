<!DOCTYPE html>
<html>
<head></head>
<body>

<h1>On the way to self-respect webapp</h1>
<ol type="A">
	<li>Click on "Run a memory game round" to play.</li>
	<li>During a game round, click on the same pattern that was presented. When the number of squares clicked are equal to the number of squares flashed, the round is evaluated.</li>
	<li>During a game round, if you make an error clicking on the sequence, click on "Reset response" to and re-click your sequence response.</li>
	<li>Click on "Restart a full game" when you would like to restart a full game.</li>
</ol>

<!-- ---------------------------------------- -->

<div id="button_container" class="button_container_class" align="left">
	<button id="run_it_button" onclick="run_it()" style="display:block">Run a memory game round</button>
	<button id="resetresponse_button" onclick="resetresponse()" style="display:none">Reset response</button>
	<button id="restart_a_new_game" onclick="restart_a_new_game()" style="display:none">Restart a new game</button>
</div>
	
<!-- ---------------------------------------- -->

<div id="canvas_container"></div>
		
<!-- ---------------------------------------- -->

<!-- View two split window -->
<div id="table_container" align="left">
<table id="results">
	<thead>
	  <tr>
	    <th scope="col" id="webapp_input">[Step 1] Explaination about game round results.</th>
	    <th scope="col" id="webapp_output">[Step 2] View game round results.</th>
	  </tr>
	</thead>
	<tbody>
	  <tr>
	    <th scope="row"><div id="accuracy_explaination"></div></th>
	    <td><div id="game_round_results"></div></td>
	  </tr>
	  <tr>
	    <th scope="row"><div id="self_respect_map"></div></th>
	    <td><div id="self_wisdom_message"></div></td>
	  </tr>
	</tbody>
</table>
</div>

<!-- ---------------------------------------- -->
	
<style>
canvas {border: 1px solid black; position: absolute; display: inline-block; z-index: 1; top: 150px;}

button { border: 2px solid white; padding-top: 10px; padding-bottom: 10px; color: white; font-weight: bold; width: 200px; margin-bottom: 5px; border-radius: 10px; background: #1743b3; box-shadow: inset 0 -3em 3em rgb(184, 198, 230 / 30%), 0 0 0 2px white, 0.3em 0.3em 1em rgb(119, 144, 201 / 60%); }

.button_container_class { display: flex; flex-direction: row; justify-content: flex-start; gap: 20px; }
	
div {position: relative; padding: 10px;}

div#accuracy_explaination { font-family:courier; font-size:16px; weight:500px; height:200px; border-radius: 10%; overflow: auto; margin-top: 20px; border: 0.5px solid #b3b3b3; background-color: rgb(220, 220, 220); }
	
div#self_respect_map { font-family:courier; font-size:16px; weight:500px; height:200px; border-radius: 10%; overflow: auto; margin-top: 20px;border: 0.5px solid #b3b3b3; background-color: rgb(220, 220, 220); }
	
div#game_round_results { font-family:courier; font-size:16px; weight:500px; height:200px; border-radius: 10%; overflow: auto; margin-top: 20px; border: 0.5px solid #b3b3b3; background-color: rgb(220, 220, 220); }
	
div#self_wisdom_message { font-family:courier; font-size:16px; weight:500px; height:200px; border-radius: 10%; overflow: auto; margin-top: 20px; border: 0.5px solid #c9715b; background-color: rgb(237, 154, 133); }

table { vertical-align: top; border-collapse: collapse; position: relative; z-index: 0; border: 0px solid black; }
table#results { text-align: left; width:500px; display:none; }
	
tr {vertical-align: top; border: 0px solid black; padding: 10px 10px; }

th, td {vertical-align: top; border: 0px solid black; padding: 10px; }
th#webapp_input {width: 100%; }
th#webapp_output {width: 100%; }
</style>


<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
<script>

// -------------------------------------------------

var squarelocation = [0, 1, 2, 3, 4, 5, 6];
	  
// Set the width and height of the canvas
var canvasElement_width = 150;  // 150
var canvasElement_height = canvasElement_width;
var canvasTopStart = 0; // 150; // 150  //75
const space_btw_each_canvas = 40; // 40;  //17
	
var user_click = [];
var order = [];

var data = [['', 'round_accuracy', 'total_accuracy', 'response_time', 'presentation_time_interval', 'flash_number']+'\n']; 
var presentation_time_interval = 2000;
var flash_number = 3;
const y_choices_flash_number_model = [3, 4, 5, 6, 7];
const y_choices_presentation_time_interval_model = [2000, 1500, 1000];
	
var response_time = 0;
var accuracy0 = 0;
var accuracy1 = 0;
var round_accuracy = 0;
var total_accuracy = 1;

var startTime = []; 
var endTime = [];

var run_it_count = 0;
var decide_to_predict = false;

var choice = 1; // 0=use csv file in repo, 1=use data array variable

var decide_to_GET_messages_from_file = false;
var message_arr = [];

// ----------------------------
// Create all the elements
// ----------------------------
var canvasElement0 = document.createElement('canvas');
var ctx0 = canvasElement0.getContext("2d");  // Get the 2D rendering context of the canvas

var canvasElement1 = document.createElement('canvas');
var ctx1 = canvasElement1.getContext("2d");

var canvasElement2 = document.createElement('canvas');
var ctx2 = canvasElement2.getContext("2d");  // Get the 2D rendering context of the canvas

var canvasElement3 = document.createElement('canvas');
var ctx3 = canvasElement3.getContext("2d");  // Get the 2D rendering context of the canvas

var canvasElement4 = document.createElement('canvas');
var ctx4 = canvasElement4.getContext("2d");  // Get the 2D rendering context of the canvas

var canvasElement5 = document.createElement('canvas');
var ctx5 = canvasElement5.getContext("2d");  // Get the 2D rendering context of the canvas

var canvasElement6 = document.createElement('canvas');
var ctx6 = canvasElement6.getContext("2d");  // Get the 2D rendering context of the canvas
	
// -------------------------------------------------
	  
// Load flash_number model Object when page loads
const inputs_m0 = tf.input({shape: [4]}); // there are 4 columns in xs
const denseLayer1_m0 = tf.layers.dense({units: 64, activation: 'relu'});
const denseLayer2_m0 = tf.layers.dense({units: 64, activation: 'relu'});
const denseLayer3_m0 = tf.layers.dense({units: 64, activation: 'relu'});
const denseLayer4_m0 = tf.layers.dense({units: 5, activation: 'softmax'});  // there are 5 possible outputs for game parameter flash_number= [3, 4, 5, 6, 7] that one can predict
const outputs_m0 = denseLayer4_m0.apply(denseLayer3_m0.apply(denseLayer2_m0.apply(denseLayer1_m0.apply(inputs_m0))));
const flash_number_model = tf.model({inputs: inputs_m0, outputs: outputs_m0});

// -------------------------------------------------
	  
// Load presentation_time_interval model Object when page loads
const inputs_m1 = tf.input({shape: [4]}); // there are 4 columns in xs
const denseLayer1_m1 = tf.layers.dense({units: 64, activation: 'relu'});
const denseLayer2_m1 = tf.layers.dense({units: 64, activation: 'relu'});
const denseLayer3_m1 = tf.layers.dense({units: 64, activation: 'relu'});
const denseLayer4_m1 = tf.layers.dense({units: 3, activation: 'softmax'});  // there are 3 possible outputs for game parameter presentation_time_interval= [2000, 1500, 1000] that one can predict
const outputs_m1 = denseLayer4_m1.apply(denseLayer3_m1.apply(denseLayer2_m1.apply(denseLayer1_m1.apply(inputs_m1))));
const presentation_time_interval_model = tf.model({inputs: inputs_m1, outputs: outputs_m1});
	  
// -------------------------------------------------

async function currentTime() { 
	let date = new Date(); 
	let hh = date.getHours(); 
	let mm = date.getMinutes(); 
	let ss = date.getSeconds();
	return [hh, mm, ss];
}
			
// -------------------------------------------------

async function elapsedTime(startTime, endTime) {
	return (endTime[0]*60*60 + endTime[1]*60 + endTime[2]) - (startTime[0]*60*60 + startTime[1]*60 + startTime[2]);
}

// -------------------------------------------------

async function initialization_of_canvasElements() {

	// ------------------------------------------
	// Predict flash_number based on past performance
	// ------------------------------------------
	if (decide_to_predict == true) {
		// Model predicted selection
		flash_number = await predict_w_pretrained_flash_number_model();
	} else {
		// Random selection
		flash_number = await rand_perm(y_choices_flash_number_model, 1)
			.then(async function (flash_number_array) {  const flash_number_scalar = flash_number_array.at(0); return flash_number_scalar});
	}
	// console.log("flash_number: ", flash_number);
	// ------------------------------------------


	// ------------------------------------------
	// Predict presentation_time_interval based on past performance
	// ------------------------------------------
	if (decide_to_predict == true) {
		// Model predicted selection
		presentation_time_interval = await predict_w_pretrained_presentation_time_interval_model();
	} else {
		// Random selection
		presentation_time_interval = await rand_perm(y_choices_presentation_time_interval_model, 1)
			.then(async function (presentation_time_interval_array) {  const presentation_time_interval_scalar = presentation_time_interval_array.at(0); return presentation_time_interval_scalar});
	}
	// console.log("presentation_time_interval: ", presentation_time_interval);
	// ------------------------------------------
	
	
	// ------------------------------------------
	// GET self-respect messages from file 
	// ------------------------------------------
	
	if (run_it_count == 0 || decide_to_GET_messages_from_file == true) {
		
		await GET_text_from_file_wo_auth_GitHub_RESTAPI_directurl()
			.then(async function(text_arr) { 
				// console.log('text_arr: ', text_arr);
				message_arr = text_arr.split('\n\n');
				// console.log('message_arr: ', message_arr);
			});
	}
	
	// ------------------------------------------
	
	canvasElement0.width = canvasElement_width;
	canvasElement0.height = canvasElement_height;
	canvasElement1.width = canvasElement_width;
	canvasElement1.height = canvasElement_height;
	canvasElement2.width = canvasElement_width;
	canvasElement2.height = canvasElement_height;
	canvasElement3.width = canvasElement_width;
	canvasElement3.height = canvasElement_height;
	canvasElement4.width = canvasElement_width;
	canvasElement4.height = canvasElement_height;
	canvasElement5.width = canvasElement_width;
	canvasElement5.height = canvasElement_height;
	canvasElement6.width = canvasElement_width;
	canvasElement6.height = canvasElement_height;

	// ------------------------------------------
	
	square_config = await Math.floor(Math.random() * 2);
	console.log("square_config: ", square_config);

	// ------------------------------------------
	
	if (square_config == 0) {
		// 0: row
		canvasElement0.style.left = Number(0*canvasElement_width + space_btw_each_canvas)+'px';
		canvasElement0.style.top = Number(0*canvasElement_width + canvasTopStart)+'px';
		
		canvasElement1.style.left = Number(1*canvasElement_width + space_btw_each_canvas)+'px';
		canvasElement1.style.top = Number(0*canvasElement_width + canvasTopStart)+'px';
		
		canvasElement2.style.left = Number(2*canvasElement_width + space_btw_each_canvas)+'px';
		canvasElement2.style.top = Number(0*canvasElement_width + canvasTopStart)+'px';
		
		canvasElement3.style.left = Number(3*canvasElement_width + space_btw_each_canvas)+'px';
		canvasElement3.style.top = Number(0*canvasElement_width + canvasTopStart)+'px';
		
		canvasElement4.style.left = Number(4*canvasElement_width + space_btw_each_canvas)+'px';
		canvasElement4.style.top = Number(0*canvasElement_width + canvasTopStart)+'px';
		
		canvasElement5.style.left = Number(5*canvasElement_width + space_btw_each_canvas)+'px';
		canvasElement5.style.top = Number(0*canvasElement_width + canvasTopStart)+'px';
		
		canvasElement6.style.left = Number(6*canvasElement_width + space_btw_each_canvas)+'px';
		canvasElement6.style.top = Number(0*canvasElement_width + canvasTopStart)+'px';
		
	} else if (square_config == 1) {
		// 1: triangle
		// -----------------------------------
		// 1st row
		canvasElement0.style.left = Number(0*canvasElement_width + (1*canvasElement_width + canvasElement_width/2 + space_btw_each_canvas)) + 'px';
		canvasElement0.style.top = Number(0*canvasElement_width + canvasTopStart)+'px';
		// -----------------------------------
		// 2nd row
		canvasElement1.style.left = Number(1*canvasElement_width) - space_btw_each_canvas+'px';
		canvasElement1.style.top = Number(1*canvasElement_width + canvasTopStart)+'px';
    
		canvasElement2.style.left = Number(2*canvasElement_width + canvasElement_width/2 + space_btw_each_canvas)+'px';
		canvasElement2.style.top = Number(1*canvasElement_width + canvasTopStart)+'px';
		// -----------------------------------
		// 3rd row
		canvasElement3.style.left = Number(0*canvasElement_width + space_btw_each_canvas)+'px';
		canvasElement3.style.top = Number(2*canvasElement_width + canvasTopStart)+'px';
    
		canvasElement4.style.left = Number(1*canvasElement_width + space_btw_each_canvas)+'px';
		canvasElement4.style.top = Number(2*canvasElement_width + canvasTopStart)+'px';
		
		canvasElement5.style.left = Number(2*canvasElement_width + space_btw_each_canvas)+'px';
		canvasElement5.style.top = Number(2*canvasElement_width + canvasTopStart)+'px';
    
		canvasElement6.style.left = Number(3*canvasElement_width + space_btw_each_canvas)+'px';
		canvasElement6.style.top = Number(2*canvasElement_width + canvasTopStart)+'px';
		// -----------------------------------
		
	} else if (square_config == 2) {
		// 2: U (square)
		// -----------------------------------
		// 1st row
		canvasElement0.style.left = Number(0*canvasElement_width + space_btw_each_canvas)+'px';
		canvasElement0.style.top = Number(0*canvasElement_width + canvasTopStart)+'px';

		canvasElement1.style.left = Number(2*canvasElement_width + space_btw_each_canvas)+'px';
		canvasElement1.style.top = Number(0*canvasElement_width + canvasTopStart)+'px';
		// -----------------------------------
		// 2nd row
		canvasElement2.style.left = Number(0*canvasElement_width + space_btw_each_canvas)+'px';
		canvasElement2.style.top = Number(1*canvasElement_width + canvasTopStart)+'px';
		
		canvasElement3.style.left = Number(2*canvasElement_width + space_btw_each_canvas)+'px';
		canvasElement3.style.top = Number(1*canvasElement_width + canvasTopStart)+'px';
		// -----------------------------------
		// 3rd row
		canvasElement4.style.left = Number(0*canvasElement_width + space_btw_each_canvas)+'px';
		canvasElement4.style.top = Number(2*canvasElement_width + canvasTopStart)+'px';
		
		canvasElement5.style.left = Number(1*canvasElement_width + space_btw_each_canvas)+'px';
		canvasElement5.style.top = Number(2*canvasElement_width + canvasTopStart)+'px';
		
		canvasElement6.style.left = Number(2*canvasElement_width + space_btw_each_canvas)+'px';
		canvasElement6.style.top = Number(2*canvasElement_width + canvasTopStart)+'px';
		// -----------------------------------
	}

	// Set a reference value for the canvasElement
	canvasElement0.setAttribute("data-id", 0);
	canvasElement1.setAttribute("data-id", 1);
	canvasElement2.setAttribute("data-id", 2);
	canvasElement3.setAttribute("data-id", 3);
	canvasElement4.setAttribute("data-id", 4);
	canvasElement5.setAttribute("data-id", 5);
	canvasElement6.setAttribute("data-id", 6);

	// Add the canvas to the DOM
	document.getElementById("canvas_container").appendChild(canvasElement0);
	document.getElementById("canvas_container").appendChild(canvasElement1);
	document.getElementById("canvas_container").appendChild(canvasElement2);
	document.getElementById("canvas_container").appendChild(canvasElement3);
	document.getElementById("canvas_container").appendChild(canvasElement4);
	document.getElementById("canvas_container").appendChild(canvasElement5);
	document.getElementById("canvas_container").appendChild(canvasElement6);

	// Make all the canvas context objects a certain initial color
	ctx0.fillStyle = '#999c98';  // Background square over image = blue
	ctx0.fillRect(0, 0, canvasElement_width, canvasElement_height);
	ctx1.fillStyle = '#999c98';  // Background square over image = blue
	ctx1.fillRect(0, 0, canvasElement_width, canvasElement_height);
	ctx2.fillStyle = '#999c98';  // Background square over image = blue
	ctx2.fillRect(0, 0, canvasElement_width, canvasElement_height);
	ctx3.fillStyle = '#999c98';  // Background square over image = blue
	ctx3.fillRect(0, 0, canvasElement_width, canvasElement_height);
	ctx4.fillStyle = '#999c98';  // Background square over image = blue
	ctx4.fillRect(0, 0, canvasElement_width, canvasElement_height);
	ctx5.fillStyle = '#999c98';  // Background square over image = blue
	ctx5.fillRect(0, 0, canvasElement_width, canvasElement_height);
	ctx6.fillStyle = '#999c98';  // Background square over image = blue
	ctx6.fillRect(0, 0, canvasElement_width, canvasElement_height);

	return flash_number;
}

// -------------------------------------------------

async function run_it() {

	// -------------------------------------------------
	// Reset screen text after a previous run
	// -------------------------------------------------
	
	// Reset all text and results
	document.getElementById('canvas_container').style.display = "block";
	document.getElementById('results').style.display = "none";

	document.getElementById("run_it_button").style.display = 'none';
	document.getElementById("restart_a_new_game").style.display = 'none';
	
	// ------------------------

	// Make canvas display setting visible
	canvasElement0.style.display = "block";
	canvasElement1.style.display = "block";
	canvasElement2.style.display = "block";
	canvasElement3.style.display = "block";
	canvasElement4.style.display = "block";
	canvasElement5.style.display = "block";
	canvasElement6.style.display = "block";

	// -------------------------------------------------

	order = await initialization_of_canvasElements()
		.then(async function(flash_number) { 
			if (flash_number == 3) {
				order = await flash_sequence_difficulty3();
			} else if (flash_number == 4) {
				order = await flash_sequence_difficulty4();
			} else if (flash_number == 5) {
				order = await flash_sequence_difficulty5();
			} else if (flash_number == 6) {
				order = await flash_sequence_difficulty6();
			} else {
				order = await flash_sequence_difficulty7();
			}
		return order; })
		.then(async function(order) { await listen_for_user_clicks(); return order; });
	
	// -------------------------------------------------

	// Count the number of times it is run
	run_it_count += 1;
	
	// -------------------------------------------------
	
	return order;
}

// -------------------------------------------------

async function restart_a_new_game() {
	window.location.href = window.location.href + '?nocache=';
}
	  
// -------------------------------------------------

async function user_click_done() {

	// The first stop_one_eventlister has the correct user_click
	return await stop_listening_for_user_clicks()
		// This gave enough time for the the global variable accuracy0 and accuracy1 to update
		.then(async function() { accuracy0 = await calculate_sequence_selection_correct(); })
		.then(async function() { accuracy1 = await calculate_color_selection_correct(); })
		.then(async function() { response_time = await elapsedTime(startTime, endTime); })
		.then(async function() { await verify_user_clicks(); });
}

// -------------------------------------------------

async function get_csvDataset() {
	
	const repoOwner = 'CodeSolutions2';
	const repoName = 'on_the_way_to_selfrespect';
	var url = `https://api.github.com/repos/${repoOwner}/${repoName}/contents`;

	var url_vec = [];
	await fetch(url).then(res => res.json()).then(data => {
		    data.forEach(file => {
		      if (file.type === 'file' && file.name.match(/.(csv|txt)$/i)) {
			url_vec.push(file.download_url);
		      }
		    });
		  }).catch(error => { console.log('error: ', error); });

   
	const get_csvDataset_URLblob = url_vec[0];
	// console.log('get_csvDataset_URLblob: ', get_csvDataset_URLblob);
    
	return get_csvDataset_URLblob;
}
	
// -------------------------------------------------

async function data_2_dictionary(data, y_choices, label_name){

	let X = [];
	let Y = [];
	let colnum;

	let xs_ind = [];
	let ys_ind = [];
	
	data.forEach(async function(rowdata, index) {

		// console.log('rowdata: ', rowdata);
		// console.log('index: ', index);

		// Remove all \n from the string rowdata
		rowdata = rowdata.replace(/\n/g, '');
		
		let out = rowdata.split(",");
		// console.log('out: ', out);

		// Remove empty columns
		let nonempty_row = out.filter((num) => num.length != 0);
		// console.log('nonempty_row: ', nonempty_row);
		
		if (index == 0){
			// header, do not save data

			// Obtain the number of columns in the xs matrix
			colnum = nonempty_row.length - 1;
			// console.log('colnum: ', colnum);
			
			// get index for what column is xs and ys
			// it needs to check all values in nonempty_row
			for (let i=0; i < nonempty_row.length; i++){
			      if (nonempty_row[i] == label_name) {
			        ys_ind.push(Number(i));
			      } else {
				xs_ind.push(Number(i));
			      }
			}
			// console.log('xs_ind: ', xs_ind);
			// console.log('ys_ind: ', ys_ind);
			
		} else {
			// Put in Object correctly
			let x_vals = [];
			xs_ind.forEach( (val, index) => {
				x_vals.push(Number(nonempty_row[val]));
			});
			X.push(x_vals);
			Y.push(Number(nonempty_row[ys_ind[0]]));
		}
		
	});

	// -------------------------------------------------
	
	// Encode Y 
	const num_of_classes = y_choices.length;
	const y_choices_assignment = Object.fromEntries(y_choices.map((key, index) => [key, index]));
	let Yencoded = [];
 	Y.forEach(async function(rowdata, index) {
		Yencoded.push(y_choices_assignment[rowdata]);
	});

	// -------------------------------------------------
	
	// Transform to tensorflow.js
	let rownum = X.length;
	const xs = tf.tensor2d(X, [rownum, colnum]);  // this is size [ 34, 4 ]
	// console.log('xs: ', xs);

	// -------------------------------------------------
	
	let ys = tf.tensor2d(Yencoded, [rownum, 1], 'int32').flatten();  // flatten the 2D tensor as a 1Dtensor
	// console.log('ys: ', ys);  // shape: Array [ 34 ]
	
	// ys needs to be in one-hot form, size [34, 5]
	ys = tf.oneHot(ys, num_of_classes);  // Array [34, 5]
	// console.log('ys: ', ys);

	// -------------------------------------------------
	
	return {xs: xs, ys: ys};
}

// -------------------------------------------------
	
async function csvDataset_2_dictionary(csvDataset, y_choices){

	let X = [];
	let Y = [];
	let colnum;
	
	const tensors = await csvDataset.toArray();
	tensors.forEach(async function(rowdata, index) {

		let col0 = Object.values(rowdata.xs);
		let col1 = Object.values(rowdata.ys);
		
		if (index < 1){
			colnum = col0.length;
			// console.log("Object.keys: ", Object.keys(rowdata)); // output is xs, ys
			// console.log("col0: " + col0);
			// console.log("col1: " + col1);
		}

		// Put in Object correctly
		X.push(col0);
		Y.push(col1);
	});

	// -------------------------------------------------
	
	// Encode Y 
	const num_of_classes = y_choices.length;
	const y_choices_assignment = Object.fromEntries(y_choices.map((key, index) => [key, index]));
	let Yencoded = [];
 	Y.forEach(async function(rowdata, index) {
		Yencoded.push(y_choices_assignment[rowdata]);
	});

	// -------------------------------------------------
	
	// Transform to tensorflow.js
	let rownum = X.length;
	const xs = tf.tensor2d(X, [rownum, colnum]);  // this is size [ 34, 4 ]
	// console.log('xs: ', xs);

	// -------------------------------------------------
	
	let ys = tf.tensor2d(Yencoded, [rownum, 1], 'int32').flatten();  // flatten the 2D tensor as a 1Dtensor
	// console.log('ys: ', ys);  // shape: Array [ 34 ]
	
	// ys needs to be in one-hot form, size [34, 5]
	ys = tf.oneHot(ys, num_of_classes);  // Array [34, 5]
	// console.log('ys: ', ys);

	// -------------------------------------------------
	
	return {xs: xs, ys: ys};
}

		  
// -------------------------------------------------

	
async function train_flash_number_model() {

	// Read dataset from location to tensorflow csvDataset object
	if (choice == 0) {
		// 0=use csv file in repo
		await get_csvDataset()
		.then(async function(get_csvDataset_URLblob) { const csvDataset = await tf.data.csv(get_csvDataset_URLblob, { columnConfigs: { flash_number: {isLabel: true} } }); return csvDataset; })
		.then(async function(csvDataset) { const dict_obj = await csvDataset_2_dictionary(csvDataset, y_choices_flash_number_model); return dict_obj; })
		.then(async function(dict_obj) { await flash_number_model.compile({optimizer: 'adam', loss: 'categoricalCrossentropy', metrics: ["accuracy"]});  return dict_obj; })
		.then(async function(dict_obj) { 
			// console.log('dict_obj.xs: ', dict_obj.xs); // Array [34, 4]
			// console.log('dict_obj.ys: ', dict_obj.ys); // Array [34, 5]
			const history = await flash_number_model.fit(dict_obj.xs, dict_obj.ys, { batchSize: 1, epochs: 10, callbacks: { onEpochEnd: async (epoch, logs) => { 
			// console.log(epoch + ', loss: ' + logs.loss + ', accuracy: ' + logs.acc); 
			} } });
			// console.log('history: ', history);
		})
		.then(async function(history) { const saveResults = await flash_number_model.save('localstorage://flash_number_model');  });
		
	} else {
		// 1=use data array variable
		await data_2_dictionary(data, y_choices_flash_number_model, "flash_number")
			.then(async function(dict_obj) { await flash_number_model.compile({optimizer: 'adam', loss: 'categoricalCrossentropy', metrics: ["accuracy"]});  return dict_obj; })
		.then(async function(dict_obj) { 
			// console.log('dict_obj.xs: ', dict_obj.xs); // Array [34, 4]
			// console.log('dict_obj.ys: ', dict_obj.ys); // Array [34, 5]
			const history = await flash_number_model.fit(dict_obj.xs, dict_obj.ys, { batchSize: 1, epochs: 10, callbacks: { onEpochEnd: async (epoch, logs) => { 
			// console.log(epoch + ', loss: ' + logs.loss + ', accuracy: ' + logs.acc); 
			} } });
			// console.log('history: ', history);
		})
		.then(async function(history) { const saveResults = await flash_number_model.save('localstorage://flash_number_model');  })
	;
	}
	
}

// -------------------------------------------------
	  
async function predict_w_pretrained_flash_number_model() {

	const flash_number_model = await tf.loadLayersModel('localstorage://flash_number_model');

	// Give previous round data
	const xs_test = tf.tensor2d([round_accuracy, total_accuracy, response_time, presentation_time_interval], [1, 4]);
	// console.log('xs_test : ', xs_test);

	const result = flash_number_model.predict( xs_test );

	// Get probability value as a number
	const probability_array = await result.data();
	// console.log('probability_array : ', probability_array);

	// Index of maximum softmax probability 
	const index = result.as1D().argMax().dataSync()[0];
	
	// Maximum probability
	const maxprob = probability_array[index];

	const prediction = y_choices_flash_number_model[index];
	
	return prediction;
}

// -------------------------------------------------
	
async function train_presentation_time_interval_model() {

	// Read dataset from location to tensorflow csvDataset object
	if (choice == 0) {
		// 0=use csv file in repo
	await get_csvDataset(choice)
		.then(async function(get_csvDataset_URLblob) { const csvDataset = await tf.data.csv(get_csvDataset_URLblob, { columnConfigs: { presentation_time_interval: {isLabel: true} } }); return csvDataset; })
		.then(async function(csvDataset) { const dict_obj = await csvDataset_2_dictionary(csvDataset, y_choices_presentation_time_interval_model); return dict_obj; })
		.then(async function(dict_obj) { await presentation_time_interval_model.compile({optimizer: 'adam', loss: 'categoricalCrossentropy', metrics: ["accuracy"]});  return dict_obj; })
		.then(async function(dict_obj) { 
			// console.log('dict_obj.xs: ', dict_obj.xs); // Array [34, 4]
			// console.log('dict_obj.ys: ', dict_obj.ys); // Array [34, 5]
			const history = await presentation_time_interval_model.fit(dict_obj.xs, dict_obj.ys, { batchSize: 1, epochs: 10, callbacks: { onEpochEnd: async (epoch, logs) => { 
			// console.log(epoch + ', loss: ' + logs.loss + ', accuracy: ' + logs.acc); 
			} } });
			// console.log('history: ', history);
		})
		.then(async function(history) { const saveResults = await presentation_time_interval_model.save('localstorage://presentation_time_interval_model');  })
	;
		
	} else {
		// 1=use data array variable
		await data_2_dictionary(data, y_choices_presentation_time_interval_model, "presentation_time_interval")
			.then(async function(dict_obj) { await presentation_time_interval_model.compile({optimizer: 'adam', loss: 'categoricalCrossentropy', metrics: ["accuracy"]});  return dict_obj; })
		.then(async function(dict_obj) { 
			// console.log('dict_obj.xs: ', dict_obj.xs); // Array [34, 4]
			// console.log('dict_obj.ys: ', dict_obj.ys); // Array [34, 5]
			const history = await presentation_time_interval_model.fit(dict_obj.xs, dict_obj.ys, { batchSize: 1, epochs: 10, callbacks: { onEpochEnd: async (epoch, logs) => { 
				// console.log(epoch + ', loss: ' + logs.loss + ', accuracy: ' + logs.acc); 
			} } });
			// console.log('history: ', history);
		})
		.then(async function(history) { const saveResults = await presentation_time_interval_model.save('localstorage://presentation_time_interval_model');  });
	}
	
}
	
// -------------------------------------------------

async function predict_w_pretrained_presentation_time_interval_model() {

	const presentation_time_interval_model = await tf.loadLayersModel('localstorage://presentation_time_interval_model');

	// Give previous round data
	const xs_test = tf.tensor2d([round_accuracy, total_accuracy, response_time, flash_number], [1, 4]);
	// console.log('xs_test : ', xs_test);

	const result = presentation_time_interval_model.predict( xs_test );

	// Get probability value as a number
	const probability_array = await result.data();

	// Index of maximum softmax probability 
	const index = result.as1D().argMax().dataSync()[0];
	
	// Maximum probability
	const maxprob = probability_array[index];

	const prediction = y_choices_presentation_time_interval_model[index];
	
	return prediction;
}
	  
// -------------------------------------------------

async function listen_for_user_clicks() {

	// Launch eventListeners on all of the canvasElements, then Make the DONE button visible
	startTime = await currentTime();
	
	await start_one_eventlister(0)
		.then(async function() { await start_one_eventlister(1); })
		.then(async function() { await start_one_eventlister(2); })
		.then(async function() { await start_one_eventlister(3); })
		.then(async function() { await start_one_eventlister(4); })
		.then(async function() { await start_one_eventlister(5); })
		.then(async function() { await start_one_eventlister(6); })
		.then(function() { document.getElementById("resetresponse_button").style.display = 'block'; });
	
}
	  
// -------------------------------------------------

async function stop_listening_for_user_clicks() {
	 
	// Launch eventListeners on all of the canvasElements, then Remove DONE button
	await stop_one_eventlister(0)
		.then(async function() { await stop_one_eventlister(1); })
		.then(async function() { await stop_one_eventlister(2); })
		.then(async function() { await stop_one_eventlister(3); })
		.then(async function() { await stop_one_eventlister(4); })
		.then(async function() { await stop_one_eventlister(5); })
		.then(async function() { await stop_one_eventlister(6); })
		.then(async () => { await new Promise(r => setTimeout(r, 200)); })
		.then(function() { document.getElementById("resetresponse_button").style.display = "none"; });

	endTime = await currentTime();
}
	  
// -------------------------------------------------
// There are two equal grading criteria for flash_number: [0] the correct sequence (accuracy0) AND [1] how many correct colors were clicked (accuracy1)
// -------------------------------------------------

async function calculate_sequence_selection_correct() {

	// Determining the correct sequence that was selected (order of selection is important): accuracy0 is from 0 to order.length
	
	// console.log('order: ', order);
	// console.log('user_click: ', user_click);

	// order and user_click are arrays. 
	// turn the arrays to a string. Compare if the two strings are exactly the same.
	if (order.toString() === user_click.toString()) {
		// If order selection is correct
		accuracy0 = order.length/2; // the maximum value is half of flash_number because there are two grading criteria.
	} else {
		// If order selection is not correct
		// count how many user_clicks were sequentially correct
		var count = 0;
		order.map((val, ind) => {
			if (val == user_click.at(ind)) {
				count = count + 1;
			}
		});
		accuracy0 = count/2;
	}
	// console.log("accuracy0: ", accuracy0);
	
	return accuracy0;
}

// -------------------------------------------------

async function calculate_color_selection_correct() {

	// Determining the correct colors that were selected (order of selection is NOT important): accuracy1 is from 0 to order.length
	
	// order and user_click are arrays. Combine the arrays into one array.
	var combined_arr = order.concat(user_click);
	// console.log('combined_arr: ', combined_arr);
	
	// Since one can only select one color per round, color selection does not repeat.
	// If the set of user_click is equivalent to combined, it means that the user selected the same colors as order, regardless of order.
	const combined  = [... new Set(combined_arr)];
	// console.log('combined: ', combined);

	const num_of_colors_that_were_not_correctly_clicked_on = combined.length - user_click.length;
	accuracy1 = (order.length - num_of_colors_that_were_not_correctly_clicked_on)/2;
	// console.log('accuracy1: ', accuracy1);
	
	return accuracy1;
}

// -------------------------------------------------

async function verify_user_clicks(){

	// ------------------------
	// Hide the canvas
	// ------------------------
	// Make canvas display setting not visible
	canvasElement0.style.display = "none";
	canvasElement1.style.display = "none";
	canvasElement2.style.display = "none";
	canvasElement3.style.display = "none";
	canvasElement4.style.display = "none";
	canvasElement5.style.display = "none";
	canvasElement6.style.display = "none";
	document.getElementById('canvas_container').style.display = "none";

	// ------------------------
	// Calculate accuracy
	// ------------------------
	const order_string = order.toString();
	const user_click_string = user_click.toString();

	// Scale round_accuracy from 0 to 1.
	// accuracy0 has a number range from 0 to order.length/2.
	// accuracy1 has a number range from 0 to order.length/2.
	round_accuracy = await (accuracy0 + accuracy1)/order.length;
	// console.log('round_accuracy: ', round_accuracy);
	
	// total_accuracy is from 0 to 1, starting at 1. If round_accuracy is from 0 to 1, then divide by 2 to make updated total_accuracy from 0 to 1.
	total_accuracy = await (total_accuracy + round_accuracy)/2;
	// console.log('total_accuracy: ', total_accuracy);


	// ------------------------
	// Print results
	// ------------------------
	document.getElementById('results').style.display = "block";

	// top left
	document.getElementById('accuracy_explaination').innerHTML = 'Round performance was calculated using two grading criteria about the quantity and sequence of squares that flashed: <ol><li>correct sequence (order of selection is important).</li><li>quantity of correct colors were clicked (order of selection is NOT important).</li></ol>The first and second grading criteria gives credit to good spatial and list memory players, respectively.' + '<br/>';
	
	// bottom left
	// Print a small map of where the user is on their path to self-respect
	var e_selection_val = Math.floor(Math.random() * 4);
	var e_selection = ['‚¨ÜÔ∏è', 'üëè', 'üôå', '‚≠ê', 'üí´'];
	document.getElementById('self_respect_map').innerHTML = 'On-the-way-to-self-respect map: you have seen '  + run_it_count + ' self-respect message/s! You are on your way to self-respect! ' + e_selection.at(e_selection_val);

	// top right
	var sequence_pattern;
	if (order_string === user_click_string) {
		sequence_pattern = "Correct: the pattern was " + order_string + ", you performed " + user_click_string + ".";
	} else {
		sequence_pattern = "Incorrect: the pattern was " + order_string + ", you performed " + user_click_string + ".";
	}
	
	document.getElementById('game_round_results').innerHTML = '<ul><li>' + sequence_pattern + '</li><li>Spatial memory credit: ' + accuracy0/(order.length/2)*100 + '%</li><li>List memory credit: ' + accuracy1/(order.length/2)*100 + '%</li><li>Round accuracy: ' + round_accuracy + '</li><li>Total accuracy: ' + total_accuracy + '</li><ul/>';
	
	// bottom right
	// Print a Self-respect Wisdom messages so that users learn self-respect (Goal of playing the game)
	const ind = run_it_count % message_arr.length; // allow messages to cycle wrt the length of the array
  	const selfRespect_wisdom_message_dict = Object.fromEntries(message_arr.map((key, index) => [index, key]));
	document.getElementById('self_wisdom_message').innerHTML = "Self-respect wisdom message: " + selfRespect_wisdom_message_dict[ind];
	
	// ------------------------
	// Save round data as an array
	// ------------------------
	data.push([round_accuracy, total_accuracy, response_time, presentation_time_interval, flash_number]+'\n'); 
	// ------------------------
	

	// ------------------------
	// Make run a new game button visible
	// ------------------------
	document.getElementById("run_it_button").style.display = 'block';
	document.getElementById("restart_a_new_game").style.display = 'block';
	// ------------------------
	
	// Reset user_click
	user_click = [];

	// ------------------------
}

// -------------------------------------------------

async function get_number(x) {
	return x[Math.round(x.length*Math.random())-1];
}

	  
async function rand_perm(x, vec_len) {

	var out = [];
	while (out.length != vec_len) {
		out = await get_number(x).then(async function(x_of_y) {
			if (out.includes(x_of_y) == false && typeof x_of_y != "undefined") { 
				out.push(x_of_y);
			}
			return [... new Set(out)]; // ensure that only unique values are stored in out
		});
	}
	
	return out;
}
	  
// -------------------------------------------------

async function flash_sequence_difficulty3(){

	order = await rand_perm(squarelocation, 3)
		.then(async function(order) { const val = await show_one_image_square(order.at(0)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(0)); return order;})
		.then(async function(order) { const val = await show_one_image_square(order.at(1)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(1)); return order;})
		.then(async function(order) { const val = await show_one_image_square(order.at(2)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(2)); return order; });

	return order;
} 


	  
async function flash_sequence_difficulty4(){

	order = await rand_perm(squarelocation, 4)
		.then(async function(order) { const val = await show_one_image_square(order.at(0)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(0)); return order;})
		.then(async function(order) { const val = await show_one_image_square(order.at(1)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(1)); return order;})
		.then(async function(order) { const val = await show_one_image_square(order.at(2)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(2)); return order; })
		.then(async function(order) { const val = await show_one_image_square(order.at(3)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(3)); return order; });

	return order;
} 



async function flash_sequence_difficulty5(){

	order = await rand_perm(squarelocation, 5)
		.then(async function(order) { const val = await show_one_image_square(order.at(0)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(0)); return order;})
		.then(async function(order) { const val = await show_one_image_square(order.at(1)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(1)); return order;})
		.then(async function(order) { const val = await show_one_image_square(order.at(2)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(2)); return order; })
		.then(async function(order) { const val = await show_one_image_square(order.at(3)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(3)); return order; })
		.then(async function(order) { const val = await show_one_image_square(order.at(4)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(4)); return order; });

	return order;
} 

	  
async function flash_sequence_difficulty6(){

	order = await rand_perm(squarelocation, 6)
		.then(async function(order) { const val = await show_one_image_square(order.at(0)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(0)); return order;})
		.then(async function(order) { const val = await show_one_image_square(order.at(1)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(1)); return order;})
		.then(async function(order) { const val = await show_one_image_square(order.at(2)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(2)); return order; })
		.then(async function(order) { const val = await show_one_image_square(order.at(3)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(3)); return order; })
		.then(async function(order) { const val = await show_one_image_square(order.at(4)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(4)); return order; })
		.then(async function(order) { const val = await show_one_image_square(order.at(5)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(5)); return order; });

	return order;
} 



async function flash_sequence_difficulty7(){

	order = await rand_perm(squarelocation, 7)
		.then(async function(order) { const val = await show_one_image_square(order.at(0)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(0)); return order;})
		.then(async function(order) { const val = await show_one_image_square(order.at(1)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(1)); return order;})
		.then(async function(order) { const val = await show_one_image_square(order.at(2)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(2)); return order; })
		.then(async function(order) { const val = await show_one_image_square(order.at(3)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(3)); return order; })
		.then(async function(order) { const val = await show_one_image_square(order.at(4)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(4)); return order; })
		.then(async function(order) { const val = await show_one_image_square(order.at(5)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(5)); return order; })
		.then(async function(order) { const val = await show_one_image_square(order.at(6)); return order; })
		.then(async (order) => { await new Promise(r => setTimeout(r, presentation_time_interval)); return order;})
		.then(async function(order) { const val = await show_one_grey_square(order.at(6)); return order; });

	return order;
} 

// -------------------------------------------------

async function flash_sequence_when_clicked_on(val){
	
	await show_one_image_square(val)
		.then(async (val) => { await new Promise(r => setTimeout(r, 200)); return val;})
		.then(async function(val) { val = await show_one_grey_square(val); });

} 

// -------------------------------------------------
	  
async function show_one_image_square(val) {
	    
            const image = new Image();
	    image.setAttribute('crossOrigin', "");
	    image.setAttribute('headers', {"Content-Type": "application/json", "Access-Control-Allow-Origin": "*"});
	    
	    if (val == 0) {
		image.onload = async () => { ctx0.drawImage(image, 0, 0, canvasElement_width, canvasElement_height); };
		image.src = "https://storage.googleapis.com/on-the-way2selfrespect/red.png";
	    } else if (val == 1) {
		image.onload = async () => { ctx1.drawImage(image, 0, 0, canvasElement_width, canvasElement_height); };
		image.src = "https://storage.googleapis.com/on-the-way2selfrespect/green.png";
	    } else if (val == 2) {
		image.onload = async () => { ctx2.drawImage(image, 0, 0, canvasElement_width, canvasElement_height); };
		image.src = "https://storage.googleapis.com/on-the-way2selfrespect/blue.png";
	    } else if (val == 3) {
		image.onload = async () => { ctx3.drawImage(image, 0, 0, canvasElement_width, canvasElement_height); };
		image.src = "https://storage.googleapis.com/on-the-way2selfrespect/cyan.png";
	    } else if (val == 4) {
		image.onload = async () => { ctx4.drawImage(image, 0, 0, canvasElement_width, canvasElement_height); };
		image.src = "https://storage.googleapis.com/on-the-way2selfrespect/yellow.png";
	    } else if (val == 5) {
		image.onload = async () => { ctx5.drawImage(image, 0, 0, canvasElement_width, canvasElement_height); };
		image.src = "https://storage.googleapis.com/on-the-way2selfrespect/magenta.png";
	    } else {
		image.onload = async () => { ctx6.drawImage(image, 0, 0, canvasElement_width, canvasElement_height); };
		image.src = "https://storage.googleapis.com/on-the-way2selfrespect/orange.png";
	    }

	return val;
}

// -------------------------------------------------


async function show_one_grey_square(val) {
	
    // Draw image on canvas
    if (val == 0) {
	ctx0.fillStyle = '#999c98';  // Background square over image = blue
	ctx0.fillRect(0, 0, canvasElement_width, canvasElement_height);
    } else if (val == 1) {
	ctx1.fillStyle = '#999c98';  // Background square over image = blue
	ctx1.fillRect(0, 0, canvasElement_width, canvasElement_height);
    } else if (val == 2) {
	ctx2.fillStyle = '#999c98';  // Background square over image = blue
	ctx2.fillRect(0, 0, canvasElement_width, canvasElement_height);
    } else if (val == 3) {
	ctx3.fillStyle = '#999c98';  // Background square over image = blue
	ctx3.fillRect(0, 0, canvasElement_width, canvasElement_height);
    } else if (val == 4) {
	ctx4.fillStyle = '#999c98';  // Background square over image = blue
	ctx4.fillRect(0, 0, canvasElement_width, canvasElement_height);
    } else if (val == 5) {
	ctx5.fillStyle = '#999c98';  // Background square over image = blue
	ctx5.fillRect(0, 0, canvasElement_width, canvasElement_height);
    } else {
	ctx6.fillStyle = '#999c98';  // Background square over image = blue
	ctx6.fillRect(0, 0, canvasElement_width, canvasElement_height);
    }

	return val;
}

// -------------------------------------------------

async function show_onehalf_grey_square(val) {
	
    // Draw image on canvas
    if (val == 0) {
	ctx0.fillStyle = '#999c98';  // Background square over image = blue
	ctx0.fillRect(0, 0, canvasElement_width, 50);
    } else if (val == 1) {
	ctx1.fillStyle = '#999c98';  // Background square over image = blue
	ctx1.fillRect(0, 0, canvasElement_width, 50);
    } else if (val == 2) {
	ctx2.fillStyle = '#999c98';  // Background square over image = blue
	ctx2.fillRect(0, 0, canvasElement_width, 50);
    } else if (val == 3) {
	ctx3.fillStyle = '#999c98';  // Background square over image = blue
	ctx3.fillRect(0, 0, canvasElement_width, 50);
    } else if (val == 4) {
	ctx4.fillStyle = '#999c98';  // Background square over image = blue
	ctx4.fillRect(0, 0, canvasElement_width, 50);
    } else if (val == 5) {
	ctx5.fillStyle = '#999c98';  // Background square over image = blue
	ctx5.fillRect(0, 0, canvasElement_width, 50);
    } else {
	ctx6.fillStyle = '#999c98';  // Background square over image = blue
	ctx6.fillRect(0, 0, canvasElement_width, 50);
    }

	return val;
}



// -------------------------------------------------

async function resetresponse() {

	user_click = [];
	await stop_listening_for_user_clicks().then(async function() {  await listen_for_user_clicks(); })
}


// -------------------------------------------------

async function processEvent(event) {
	
    // When the user clicks the square, save value
    const out = this.getAttribute("data-id");
    const out1 = Number(out);
    user_click.push( out1 );
	
    if (user_click.length == order.length){
	    // Click on thhe invisible button
	    await user_click_done();
	    
	    // Train the model every XX rounds
	    if (run_it_count % 2 == 0){
		    await train_flash_number_model();
		    await train_presentation_time_interval_model();
		    decide_to_predict = true;
	     } else {
		    decide_to_predict = false;
	    }

	    // GET self-respect messages from file when all the file messages are read
	    if (run_it_count % 10 == 0){
		    decide_to_GET_messages_from_file = true;
	     } else {
		    decide_to_GET_messages_from_file = false;
	    }
	    
    }

    // When the user clicks the square, flash the square and make the square full color
    await flash_sequence_when_clicked_on(this.getAttribute("data-id"));
}

	  
async function start_one_eventlister(val) {

    // When the eventlister is turned on for each square, show image first then half of the square to hide image [seeing half or no image could be another spatial difficulty parameter]
    await show_one_image_square(val)
    .then(async (val) => { await new Promise(r => setTimeout(r, 200)); return val;})
    .then(async function(val) { val = await show_onehalf_grey_square(val); return val; })
    .then(function(val) {
							       
     	// Start an eventlister per canvas to evaluate user response
	    if (val == 0) {
		// canvasElement0.addEventListener("click", (event) => { user_click.push(val); }, false); // it duplicates each val by the number of time "run it" is pushed. This format apparently has no reference to the eventListener because no function is called (the processEvent allows javascript to track canvasElement0), so one can not remove it, thus it keeps running.
		// OR
		canvasElement0.addEventListener("click", processEvent, false);
	    } else if (val == 1) {
		canvasElement1.addEventListener("click", processEvent, false);
	    } else if (val == 2) {
		canvasElement2.addEventListener("click", processEvent, false);
	    } else if (val == 3) {
		canvasElement3.addEventListener("click", processEvent, false);
	    } else if (val == 4) {
		canvasElement4.addEventListener("click", processEvent, false);
	    } else if (val == 5) {
		canvasElement5.addEventListener("click", processEvent, false);
	    } else {
		canvasElement6.addEventListener("click", processEvent, false);
	    }			       
							       
    });
	
} 
	  
// -------------------------------------------------

async function stop_one_eventlister(val) {
	
    // Start an eventlister per canvas to evaluate user response
    if (val == 0) {
	canvasElement0.removeEventListener("click", processEvent);
    } else if (val == 1) {
	canvasElement1.removeEventListener("click", processEvent);
    } else if (val == 2) {
	canvasElement2.removeEventListener("click", processEvent);
    } else if (val == 3) {
	canvasElement3.removeEventListener("click", processEvent);
    } else if (val == 4) {
	canvasElement4.removeEventListener("click", processEvent);
    } else if (val == 5) {
	canvasElement5.removeEventListener("click", processEvent);
    } else {
	canvasElement6.removeEventListener("click", processEvent);
    }
	
}

// -------------------------------------------------

async function GET_text_from_file_wo_auth_GitHub_RESTAPI_directurl() {
  
  var file_download_url = "https://raw.githubusercontent.com/CodeSolutions2/on_the_way_to_selfrespect/main/self_respect_messages.txt"; 
  
	return await fetch(file_download_url)
		.then(res => res.text())
		.then(data => { return data; })
		.catch(error => { console.log(error); });
}

// ----------------------------------------------------


</script>
</body>
</html>
